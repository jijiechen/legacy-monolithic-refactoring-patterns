大型遗留系统中的典型现象
========

* 缺乏抽象，大量的重复代码
* 没有自动化测试
* 同一个类被到处复制，但又略有不同
* 在 JSP 里使用弱类型的模型（或没有模型）
* 在 JSP 里写包含逻辑的后端代码
* IE Only 的页面脚本
* 使用 exception 作为流程控制机制
* 把 exception 的详细信息输出到了 HTTP 响应中
* 使用错误提示作为返回值
* 被不当吞噬的异常
* 没有明显的分层，或模块化
* 大量而零散的 Utils、Common、Tools
* 把 Error Code 放到了 Response Entity 中
* 使用大量的行内（inline）SQL，拼接的 SQL（而不是参数化）
* 使用由多个方法分别提供 SQL 片断组成的行内 SQL
* 没有使用路由系统，使用 Plain Servlet，然后 switch/case
* 在整个系统中，存在多种“架构模式”、“范式”、“小框架”、比如，同在一个软件包中，有基于事件的，也有同步的；有基于 Servlet 的 Web 处理程序，还有基于 Spring 的 Web 应用
* 同一个软件包，有为多种访问入口服务。比如，既为 Web 提供服务，又为定时任务提供服务
* 做同一件事时，使用了不同的第三方工具和库，比如，JSON 序列化时，某处使用了 fastjson，其他处使用了 jackson
* 超大的文件，超长的方法，大量的分支判断，圈复杂度高
* 过期的注释
* 被注释掉的代码
* 不必要的控制台输出
* 使用类的静态初始化器
* 有状态（Session）的 HTTP 服务
* 老旧的通信方式（比如，SOAP）
* 必须依赖文件的配置
* 倾向于硬依赖（方法体内部直接依赖），而不是传入式依赖
